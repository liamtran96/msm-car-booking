# PostgreSQL - Misc (Part 14)

## 


**URL:** https://www.postgresql.org/docs/18/spi-spi-execute-plan-extended.html

**Contents:**
- SPI_execute_plan_extended
- Synopsis
- Description
- Arguments
- Return Value

SPI_execute_plan_extended — execute a statement prepared by SPI_prepare

SPI_execute_plan_extended executes a statement prepared by SPI_prepare or one of its siblings. This function is equivalent to SPI_execute_plan, except that information about the parameter values to be passed to the query is presented differently, and additional execution-controlling options can be passed.

Query parameter values are represented by a ParamListInfo struct, which is convenient for passing down values that are already available in that format. Dynamic parameter sets can also be used, via hook functions specified in ParamListInfo.

Also, instead of always accumulating the result tuples into a SPI_tuptable structure, tuples can be passed to a caller-supplied DestReceiver object as they are generated by the executor. This is particularly helpful for queries that might generate many tuples, since the data can be processed on-the-fly instead of being accumulated in memory.

prepared statement (returned by SPI_prepare)

struct containing optional arguments

Callers should always zero out the entire options struct, then fill whichever fields they want to set. This ensures forward compatibility of code, since any fields that are added to the struct in future will be defined to behave backwards-compatibly if they are zero. The currently available options fields are:

data structure containing query parameter types and values; NULL if none

true for read-only execution

true allows non-atomic execution of CALL and DO statements (but this field is ignored unless the SPI_OPT_NONATOMIC flag was passed to SPI_connect_ext)

if true, raise error if the query is not of a kind that returns tuples (this does not forbid the case where it happens to return zero tuples)

maximum number of rows to return, or 0 for no limit

DestReceiver object that will receive any tuples emitted by the query; if NULL, result tuples are accumulated into a SPI_tuptable structure, as in SPI_execute_plan

The resource owner that will hold a reference count on the plan while it is executed. If NULL, CurrentResourceOwner is used. Ignored for non-saved plans, as SPI does not acquire reference counts on those.

The return value is the same as for SPI_execute_plan.

When options->dest is NULL, SPI_processed and SPI_tuptable are set as in SPI_execute_plan. When options->dest is not NULL, SPI_processed is set to zero and SPI_tuptable is set to NULL. If a tuple count is required, the caller's DestReceiver object must calculate it.

**Examples:**

Example 1 (unknown):
```unknown
SPI_prepare
```

Example 2 (unknown):
```unknown
SPI_execute_plan_extended
```

Example 3 (unknown):
```unknown
SPI_prepare
```

Example 4 (unknown):
```unknown
SPI_execute_plan
```

---


---

## 


**URL:** https://www.postgresql.org/docs/18/spi-realloc.html

**Contents:**
- SPI_repalloc
- Synopsis
- Description
- Arguments
- Return Value

SPI_repalloc — reallocate memory in the upper executor context

SPI_repalloc changes the size of a memory segment previously allocated using SPI_palloc.

This function is no longer different from plain repalloc. It's kept just for backward compatibility of existing code.

pointer to existing storage to change

size in bytes of storage to allocate

pointer to new storage space of specified size with the contents copied from the existing area

**Examples:**

Example 1 (unknown):
```unknown
SPI_repalloc
```

Example 2 (unknown):
```unknown
void * pointer
```

---


---

## 


**URL:** https://www.postgresql.org/docs/18/spi-spi-gettype.html

**Contents:**
- SPI_gettype
- Synopsis
- Description
- Arguments
- Return Value

SPI_gettype — return the data type name of the specified column

SPI_gettype returns a copy of the data type name of the specified column. (You can use pfree to release the copy of the name when you don't need it anymore.)

input row description

column number (count starts at 1)

The data type name of the specified column, or NULL on error. SPI_result is set to SPI_ERROR_NOATTRIBUTE on error.

**Examples:**

Example 1 (unknown):
```unknown
SPI_gettype
```

Example 2 (unknown):
```unknown
TupleDesc rowdesc
```

Example 3 (unknown):
```unknown
int colnumber
```

Example 4 (unknown):
```unknown
SPI_ERROR_NOATTRIBUTE
```

---


---

## 


**URL:** https://www.postgresql.org/docs/18/spi-spi-finish.html

**Contents:**
- SPI_finish
- Synopsis
- Description
- Return Value

SPI_finish — disconnect a C function from the SPI manager

SPI_finish closes an existing connection to the SPI manager. You must call this function after completing the SPI operations needed during your C function's current invocation. You do not need to worry about making this happen, however, if you abort the transaction via elog(ERROR). In that case SPI will clean itself up automatically.

if properly disconnected

if called from an unconnected C function

**Examples:**

Example 1 (unknown):
```unknown
elog(ERROR)
```

Example 2 (unknown):
```unknown
SPI_OK_FINISH
```

Example 3 (unknown):
```unknown
SPI_ERROR_UNCONNECTED
```

---


---

## 


**URL:** https://www.postgresql.org/docs/18/spi-spi-cursor-parse-open.html

**Contents:**
- SPI_cursor_parse_open
- Synopsis
- Description
- Arguments
- Return Value

SPI_cursor_parse_open — set up a cursor using a query string and parameters

SPI_cursor_parse_open sets up a cursor (internally, a portal) that will execute the specified query string. This is comparable to SPI_prepare_cursor followed by SPI_cursor_open_with_paramlist, except that parameter references within the query string are handled entirely by supplying a ParamListInfo object.

For one-time query execution, this function should be preferred over SPI_prepare_cursor followed by SPI_cursor_open_with_paramlist. If the same command is to be executed with many different parameters, either method might be faster, depending on the cost of re-planning versus the benefit of custom plans.

The options->params object should normally mark each parameter with the PARAM_FLAG_CONST flag, since a one-shot plan is always used for the query.

The passed-in parameter data will be copied into the cursor's portal, so it can be freed while the cursor still exists.

name for portal, or NULL to let the system select a name

struct containing optional arguments

Callers should always zero out the entire options struct, then fill whichever fields they want to set. This ensures forward compatibility of code, since any fields that are added to the struct in future will be defined to behave backwards-compatibly if they are zero. The currently available options fields are:

data structure containing query parameter types and values; NULL if none

integer bit mask of cursor options; zero produces default behavior

true for read-only execution

Pointer to portal containing the cursor. Note there is no error return convention; any error will be reported via elog.

**Examples:**

Example 1 (unknown):
```unknown
SPI_cursor_parse_open
```

Example 2 (unknown):
```unknown
SPI_prepare_cursor
```

Example 3 (unknown):
```unknown
SPI_cursor_open_with_paramlist
```

Example 4 (unknown):
```unknown
ParamListInfo
```

---


---

## 30.4. Extensibility #


**URL:** https://www.postgresql.org/docs/18/jit-extensibility.html

**Contents:**
- 30.4. Extensibility #
  - 30.4.1. Inlining Support for Extensions #
  - Note
  - 30.4.2. Pluggable JIT Providers #
    - 30.4.2.1. JIT Provider Interface #

PostgreSQL's JIT implementation can inline the bodies of functions of types C and internal, as well as operators based on such functions. To do so for functions in extensions, the definitions of those functions need to be made available. When using PGXS to build an extension against a server that has been compiled with LLVM JIT support, the relevant files will be built and installed automatically.

The relevant files have to be installed into $pkglibdir/bitcode/$extension/ and a summary of them into $pkglibdir/bitcode/$extension.index.bc, where $pkglibdir is the directory returned by pg_config --pkglibdir and $extension is the base name of the extension's shared library.

For functions built into PostgreSQL itself, the bitcode is installed into $pkglibdir/bitcode/postgres.

PostgreSQL provides a JIT implementation based on LLVM. The interface to the JIT provider is pluggable and the provider can be changed without recompiling (although currently, the build process only provides inlining support data for LLVM). The active provider is chosen via the setting jit_provider.

A JIT provider is loaded by dynamically loading the named shared library. The normal library search path is used to locate the library. To provide the required JIT provider callbacks and to indicate that the library is actually a JIT provider, it needs to provide a C function named _PG_jit_provider_init. This function is passed a struct that needs to be filled with the callback function pointers for individual actions:

**Examples:**

Example 1 (bash):
```bash
$pkglibdir/bitcode/$extension/
```

Example 2 (bash):
```bash
$pkglibdir/bitcode/$extension.index.bc
```

Example 3 (unknown):
```unknown
pg_config --pkglibdir
```

Example 4 (bash):
```bash
$pkglibdir/bitcode/postgres
```

---


---

## 


**URL:** https://www.postgresql.org/docs/18/spi-spi-register-trigger-data.html

**Contents:**
- SPI_register_trigger_data
- Synopsis
- Description
- Arguments
- Return Value

SPI_register_trigger_data — make ephemeral trigger data available in SPI queries

SPI_register_trigger_data makes any ephemeral relations captured by a trigger available to queries planned and executed through the current SPI connection. Currently, this means the transition tables captured by an AFTER trigger defined with a REFERENCING OLD/NEW TABLE AS ... clause. This function should be called by a PL trigger handler function after connecting.

the TriggerData object passed to a trigger handler function as fcinfo->context

If the execution of the command was successful then the following (nonnegative) value will be returned:

if the captured trigger data (if any) has been successfully registered

On error, one of the following negative values is returned:

if called from an unconnected C function

if the name of any trigger data transient relation is already registered for this connection

**Examples:**

Example 1 (unknown):
```unknown
SPI_register_trigger_data
```

Example 2 (unknown):
```unknown
REFERENCING OLD/NEW TABLE AS
```

Example 3 (unknown):
```unknown
TriggerData *tdata
```

Example 4 (unknown):
```unknown
TriggerData
```

---


---

