# PostgreSQL - Misc (Part 6)

## 


**URL:** https://www.postgresql.org/docs/18/spi-spi-cursor-close.html

**Contents:**
- SPI_cursor_close
- Synopsis
- Description
- Arguments

SPI_cursor_close — close a cursor

SPI_cursor_close closes a previously created cursor and releases its portal storage.

All open cursors are closed automatically at the end of a transaction. SPI_cursor_close need only be invoked if it is desirable to release resources sooner.

portal containing the cursor

**Examples:**

Example 1 (unknown):
```unknown
SPI_cursor_close
```

Example 2 (unknown):
```unknown
SPI_cursor_close
```

Example 3 (unknown):
```unknown
Portal portal
```

---


---

## 


**URL:** https://www.postgresql.org/docs/18/spi-spi-execute.html

**Contents:**
- SPI_execute
- Synopsis
- Description
- Arguments
- Return Value
- Notes

SPI_execute — execute a command

SPI_execute executes the specified SQL command for count rows. If read_only is true, the command must be read-only, and execution overhead is somewhat reduced.

This function can only be called from a connected C function.

If count is zero then the command is executed for all rows that it applies to. If count is greater than zero, then no more than count rows will be retrieved; execution stops when the count is reached, much like adding a LIMIT clause to the query. For example,

will retrieve at most 5 rows from the table. Note that such a limit is only effective when the command actually returns rows. For example,

inserts all rows from bar, ignoring the count parameter. However, with

at most 5 rows would be inserted, since execution would stop after the fifth RETURNING result row is retrieved.

You can pass multiple commands in one string; SPI_execute returns the result for the command executed last. The count limit applies to each command separately (even though only the last result will actually be returned). The limit is not applied to any hidden commands generated by rules.

When read_only is false, SPI_execute increments the command counter and computes a new snapshot before executing each command in the string. The snapshot does not actually change if the current transaction isolation level is SERIALIZABLE or REPEATABLE READ, but in READ COMMITTED mode the snapshot update allows each command to see the results of newly committed transactions from other sessions. This is essential for consistent behavior when the commands are modifying the database.

When read_only is true, SPI_execute does not update either the snapshot or the command counter, and it allows only plain SELECT commands to appear in the command string. The commands are executed using the snapshot previously established for the surrounding query. This execution mode is somewhat faster than the read/write mode due to eliminating per-command overhead. It also allows genuinely stable functions to be built: since successive executions will all use the same snapshot, there will be no change in the results.

It is generally unwise to mix read-only and read-write commands within a single function using SPI; that could result in very confusing behavior, since the read-only queries would not see the results of any database updates done by the read-write queries.

The actual number of rows for which the (last) command was executed is returned in the global variable SPI_processed. If the return value of the function is SPI_OK_SELECT, SPI_OK_INSERT_RETURNING, SPI_OK_DELETE_RETURNING, SPI_OK_UPDATE_RETURNING, or SPI_OK_MERGE_RETURNING, then you can use the global pointer SPITupleTable *SPI_tuptable to access the result rows. Some utility commands (such as EXPLAIN) also return row sets, and SPI_tuptable will contain the result in these cases too. Some utility commands (COPY, CREATE TABLE AS) don't return a row set, so SPI_tuptable is NULL, but they still return the number of rows processed in SPI_processed.

The structure SPITupleTable is defined thus:

The fields tupdesc, vals, and numvals can be used by SPI callers; the remaining fields are internal. vals is an array of pointers to rows. The number of rows is given by numvals (for somewhat historical reasons, this count is also returned in SPI_processed). tupdesc is a row descriptor which you can pass to SPI functions dealing with rows.

SPI_finish frees all SPITupleTables allocated during the current C function. You can free a particular result table earlier, if you are done with it, by calling SPI_freetuptable.

string containing command to execute

true for read-only execution

maximum number of rows to return, or 0 for no limit

If the execution of the command was successful then one of the following (nonnegative) values will be returned:

if a SELECT (but not SELECT INTO) was executed

if a SELECT INTO was executed

if an INSERT was executed

if a DELETE was executed

if an UPDATE was executed

if a MERGE was executed

if an INSERT RETURNING was executed

if a DELETE RETURNING was executed

if an UPDATE RETURNING was executed

if a MERGE RETURNING was executed

if a utility command (e.g., CREATE TABLE) was executed

if the command was rewritten into another kind of command (e.g., UPDATE became an INSERT) by a rule.

On error, one of the following negative values is returned:

if command is NULL or count is less than 0

if COPY TO stdout or COPY FROM stdin was attempted

if a transaction manipulation command was attempted (BEGIN, COMMIT, ROLLBACK, SAVEPOINT, PREPARE TRANSACTION, COMMIT PREPARED, ROLLBACK PREPARED, or any variant thereof)

if the command type is unknown (shouldn't happen)

if called from an unconnected C function

All SPI query-execution functions set both SPI_processed and SPI_tuptable (just the pointer, not the contents of the structure). Save these two global variables into local C function variables if you need to access the result table of SPI_execute or another query-execution function across later calls.

**Examples:**

Example 1 (unknown):
```unknown
SPI_execute
```

Example 2 (sql):
```sql
SPI_execute("SELECT * FROM foo", true, 5);
```

Example 3 (sql):
```sql
SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
```

Example 4 (sql):
```sql
SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
```

---


---

## 


**URL:** https://www.postgresql.org/docs/18/spi-spi-exec.html

**Contents:**
- SPI_exec
- Synopsis
- Description
- Arguments
- Return Value

SPI_exec — execute a read/write command

SPI_exec is the same as SPI_execute, with the latter's read_only parameter always taken as false.

string containing command to execute

maximum number of rows to return, or 0 for no limit

**Examples:**

Example 1 (unknown):
```unknown
SPI_execute
```

Example 2 (unknown):
```unknown
const char * command
```

Example 3 (unknown):
```unknown
SPI_execute
```

---


---

## 


**URL:** https://www.postgresql.org/docs/18/spi-spi-cursor-open-with-paramlist.html

**Contents:**
- SPI_cursor_open_with_paramlist
- Synopsis
- Description
- Arguments
- Return Value

SPI_cursor_open_with_paramlist — set up a cursor using parameters

SPI_cursor_open_with_paramlist sets up a cursor (internally, a portal) that will execute a statement prepared by SPI_prepare. This function is equivalent to SPI_cursor_open except that information about the parameter values to be passed to the query is presented differently. The ParamListInfo representation can be convenient for passing down values that are already available in that format. It also supports use of dynamic parameter sets via hook functions specified in ParamListInfo.

The passed-in parameter data will be copied into the cursor's portal, so it can be freed while the cursor still exists.

name for portal, or NULL to let the system select a name

prepared statement (returned by SPI_prepare)

data structure containing parameter types and values; NULL if none

true for read-only execution

Pointer to portal containing the cursor. Note there is no error return convention; any error will be reported via elog.

**Examples:**

Example 1 (unknown):
```unknown
SPI_cursor_open_with_paramlist
```

Example 2 (unknown):
```unknown
SPI_prepare
```

Example 3 (unknown):
```unknown
SPI_cursor_open
```

Example 4 (unknown):
```unknown
ParamListInfo
```

---


---

## 


**URL:** https://www.postgresql.org/docs/18/spi-spi-execute-extended.html

**Contents:**
- SPI_execute_extended
- Synopsis
- Description
- Arguments
- Return Value

SPI_execute_extended — execute a command with out-of-line parameters

SPI_execute_extended executes a command that might include references to externally supplied parameters. The command text refers to a parameter as $n, and the options->params object (if supplied) provides values and type information for each such symbol. Various execution options can be specified in the options struct, too.

The options->params object should normally mark each parameter with the PARAM_FLAG_CONST flag, since a one-shot plan is always used for the query.

If options->dest is not NULL, then result tuples are passed to that object as they are generated by the executor, instead of being accumulated in SPI_tuptable. Using a caller-supplied DestReceiver object is particularly helpful for queries that might generate many tuples, since the data can be processed on-the-fly instead of being accumulated in memory.

struct containing optional arguments

Callers should always zero out the entire options struct, then fill whichever fields they want to set. This ensures forward compatibility of code, since any fields that are added to the struct in future will be defined to behave backwards-compatibly if they are zero. The currently available options fields are:

data structure containing query parameter types and values; NULL if none

true for read-only execution

true allows non-atomic execution of CALL and DO statements (but this field is ignored unless the SPI_OPT_NONATOMIC flag was passed to SPI_connect_ext)

if true, raise error if the query is not of a kind that returns tuples (this does not forbid the case where it happens to return zero tuples)

maximum number of rows to return, or 0 for no limit

DestReceiver object that will receive any tuples emitted by the query; if NULL, result tuples are accumulated into a SPI_tuptable structure, as in SPI_execute

This field is present for consistency with SPI_execute_plan_extended, but it is ignored, since the plan used by SPI_execute_extended is never saved.

The return value is the same as for SPI_execute.

When options->dest is NULL, SPI_processed and SPI_tuptable are set as in SPI_execute. When options->dest is not NULL, SPI_processed is set to zero and SPI_tuptable is set to NULL. If a tuple count is required, the caller's DestReceiver object must calculate it.

**Examples:**

Example 1 (unknown):
```unknown
SPI_execute_extended
```

Example 2 (php):
```php
options->params
```

Example 3 (php):
```php
options->params
```

Example 4 (unknown):
```unknown
PARAM_FLAG_CONST
```

---


---

